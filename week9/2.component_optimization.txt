--------------------------- 많은 데이터 렌더링 ---------------------------
App.js
import { useState, useRef, useCallback } from 'react'
import TodoTemplate from './components/TodoTemplate
import TodoInsert from './components/TodoInsert
import TodoList from './components/TodoList;

function createBulkTodos() {
    const array = [];
    
    for(let i=1; i<=2500; i++){
        array.push({
            id: i,
            text: `할 일 ${i}`,
            checked: false,
        })
    }

    return array;
}

const App = () => {    
    //함수 형식으로 전달 시 리렌더링될때마다 호출 createBulkTodos()
    //변수 형식으로 전달 시 컴포넌트 처음 렌더링시에만 실행
    const [todos, setTodos] = useState(createBulkTodos)

    const nextId = useRef(2501);

    const onInsert = useCallback(
        text => {
            const todo = {
                id: nextId.current,
                text,
                checked: false,
            };

            setTodos(todos.concat(todo))
            nextId.current += 1;
        },
        [todos],
    )

    const onRemove = useCallback(
        id => {
            setTodos(todos.filter(todo => todo.id !== id))
        },
        [todos],
    )

    const onToggle = useCallback(
        id => {
            setTodos(
                todos.map(todo => 
                    todo.id === id ? { ...todo, checked: !todo.checked} : todo
                ),
            )
        },
        [todos]
    )

    return (
        <TodoTemplate>
            <TodoInsert onInsert={onInsert} />
            <TodoList todos={todos} onRemove={onRemove} onToggle={onToggle}/>
        </TodoTemplate>
    )
}

export default App;

렌더링 시간 성능 측정
리액트 개발자 도구의 Components의 Profiler 탭을 열면 좌측 상단에 파란색 녹화 버튼을 누른다
이 버튼을 누르고 할 일 1 항목을 체크한 다음 화면에 변화가 반영되면 녹화 버튼을 누른다


--------------------------- React.memo를 사용하여 컴포넌트 성능 최적화 ---------------------------
TodoListItem.js
//추가
import React from 'react'
import {
    MdCheckBoxOutlineBlank,
    MdCheckBox,
    MdRemoveCircleOutline,
} from 'react-icons/md'
import cn from 'classname'
import './TodoListItme.scss'

const TodoListItme = ({ todo, onRemove }) => {
    const { id, text, checked } = todo;

    return (
        <div className="TodoListItme">
            <div className={cn('checkbox', { checked })}>
                {checked ? <MdCheckBox /> : <MdCheckBoxOutlineBlank />}
                <div className="text">{text}</div>
            </div>
            <div className="remove" onClick={() => onRemove(id)}>
                <MdRemoveCircleOutline />
            </div>
        </div>
    )
}

//추가 (props가 바뀌지 않았다면 리렌더링 방지)
export default React.memo(TodoListItem);


--------------------------- onToggle, onRemove 최적화 ---------------------------
todos 배열이 업데이트 되면 onRemove와 onToggle 함수도 새롭게 바뀐다
배열 상태를 업데이트하는 과정에서 함수가 새로 만들어진다

useState에 상태 대신에 상태 업데이트를 어떻게 할지 정의해 주는 업데이트 함수를 넣을 수도 있다
이를 함수형 업데이트라고 부른다

예시
const [number, setNumber] = useState(0)
//prevNumber는 현재 number 값을 가리킨다.
//number + 1 대신 업데이트를 정의한 함수를 넣었다 그러면 useCallback을 사용할 때 두 번째 파라미터로 넣는 배열에 number를 넣지 않아도 된다
cosnt onIncrease = useCallback(
    () => setNumber(prevNumber => prevNumber + 1)
)

App.js
import { useState, useRef, useCallback } from 'react'
import TodoTemplate from './components/TodoTemplate
import TodoInsert from './components/TodoInsert
import TodoList from './components/TodoList;

function createBulkTodos() {
    const array = [];
    
    for(let i=1; i<=2500; i++){
        array.push({
            id: i,
            text: `할 일 ${i}`,
            checked: false,
        })
    }

    return array;
}

const App = () => {    
    //함수 형식으로 전달 시 리렌더링될때마다 호출 createBulkTodos()
    //변수 형식으로 전달 시 컴포넌트 처음 렌더링시에만 실행
    const [todos, setTodos] = useState(createBulkTodos)

    const nextId = useRef(2501);

    const onInsert = useCallback(
        text => {
            const todo = {
                id: nextId.current,
                text,
                checked: false,
            };

            //추가
            setTodos(todos => todos.concat(todo))
            nextId.current += 1;
        },
        [],
    )

    //추가
    const onRemove = useCallback(
        id => {
            setTodos(todos => todos.filter(todo => todo.id !== id))
        },
        [],
    )

    //추가
    const onToggle = useCallback(
        id => {
            setTodos(todos =>
                todos.map(todo => 
                    todo.id === id ? { ...todo, checked: !todo.checked} : todo
                ),
            )
        },
        []
    )

    return (
        <TodoTemplate>
            <TodoInsert onInsert={onInsert} />
            <TodoList todos={todos} onRemove={onRemove} onToggle={onToggle}/>
        </TodoTemplate>
    )
}

export default App;


useState의 함수형 업데이트 대신 useReducer를 사용해서 최적화 할 수 있다
App.js
import { useState, useRef, useCallback } from 'react'
import TodoTemplate from './components/TodoTemplate
import TodoInsert from './components/TodoInsert
import TodoList from './components/TodoList;

function createBulkTodos() {
    const array = [];
    
    for(let i=1; i<=2500; i++){
        array.push({
            id: i,
            text: `할 일 ${i}`,
            checked: false,
        })
    }

    return array;
}

//추가
function todoReducer(todos, action){
    switch(action.type){
        case 'INSERT':
            return todos.concat(action.todo)
        case 'REMOVE':
            return todos.filter(todo => todo.id !== action.id)
        case 'TOGGLE':
            return todos.map(todo =>
                todo.id === action.id ? { ...todo, checked: !todo.checked } : todo,
            )
        default:
            return todos;       
    }
}

const App = () => {    
    //추가
    //초기값에 undefined를 주고 세 번째 파라미터에 초기 상태를 만들어 주는 함수를 전달하면
    //컴포넌트 최초 렌더링 시에만 createBulkTodos 수행
    const [todos, dispatch] = useReducer(todoReducer, undefined, createBulkTodos)
    const nextId = useRef(2501);

    const onInsert = useCallback(
        text => {
            const todo = {
                id: nextId.current,
                text,
                checked: false,
            };

            //추가
            dispatch({ type: 'INSERT', todo })
            nextId.current += 1;
        },[])

    //추가
    const onRemove = useCallback(
        id => {
            dispatch({ type: 'REMOVE', id })
        },[])

    //추가
    const onToggle = useCallback(
        id => { 
            dispatch({ type: 'TOGGLE', id}) 
        },[])

    return (
        <TodoTemplate>
            <TodoInsert onInsert={onInsert} />
            <TodoList todos={todos} onRemove={onRemove} onToggle={onToggle}/>
        </TodoTemplate>
    )
}

export default App;

useReducer는 기존 코드를 많이 고쳐야 한다는 단점이 있지만 상태를 업데이트 하는 로직을 모아서 
컴포넌트 바깥에 둘 수 있다는 장점이 있다
성능상 비슷하기 때문에 취향에 따라 결정하면 된다
